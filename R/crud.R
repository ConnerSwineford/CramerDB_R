# -- Public API ---------------------------------------------------------------

#' Create new records via API (POST)
#' @param url Endpoint like "http://host/api/veg-rec/visit/" (collection URL)
#' @param data data.frame or sf tibble
#' @param headers named list of HTTP headers (e.g., list(Authorization = "Token ..."))
#' @param id_col primary key col (default "id"). If missing or NA, server may assign.
#' @param style "auto", "plain", or "feature" (GeoJSON Feature). "auto" picks "feature" for sf, else "plain".
#' @param chunk_size number of rows per request batch (each row is one request; chunking controls progress/messages)
#' @export
create <- function(url, data, headers = list(), id_col = "id",
                   style = c("auto", "plain", "feature"), chunk_size = 200L) {
  style <- match.arg(style)
  style <- .pick_style(style, data)
  rows  <- .as_row_list(data, id_col)
  purrr::walk(.chunk_indices(NROW(data), chunk_size), function(ix) {
    purrr::walk(ix, function(i) .post_one(url, rows[[i]], headers, style))
  })
  invisible(TRUE)
}

#' Update records via API (PATCH by id)
#' @export
update <- function(url, data, headers = list(), id_col = "id",
                   style = c("auto", "plain", "feature"), chunk_size = 200L) {
  style <- match.arg(style)
  style <- .pick_style(style, data)
  if (!id_col %in% names(data)) stop("update(): '", id_col, "' column is required.")
  if (any(is.na(data[[id_col]]) | data[[id_col]] == "")) {
    warning("update(): rows with missing '", id_col, "' will be skipped.")
  }
  rows <- .as_row_list(data, id_col)
  purrr::walk(.chunk_indices(NROW(data), chunk_size), function(ix) {
    purrr::walk(ix, function(i) {
      rid <- rows[[i]][[id_col]]
      if (is.null(rid) || is.na(rid) || !nzchar(as.character(rid))) return(invisible(NULL))
      .patch_one(.join_url(url, rid), rows[[i]], headers, style)
    })
  })
  invisible(TRUE)
}

#' Upsert records via API (PATCH if id present & exists; otherwise POST)
#' @export
upsert <- function(url, data, headers = list(), id_col = "id",
                   style = c("auto", "plain", "feature"), chunk_size = 200L) {
  style <- match.arg(style)
  style <- .pick_style(style, data)
  rows <- .as_row_list(data, id_col)
  
  purrr::walk(.chunk_indices(NROW(data), chunk_size), function(ix) {
    purrr::walk(ix, function(i) {
      row <- rows[[i]]
      rid <- row[[id_col]]
      if (!is.null(rid) && !is.na(rid) && nzchar(as.character(rid))) {
        # Try PATCH; if 404, POST as create
        ok <- .try_patch(.join_url(url, rid), row, headers, style)
        if (!ok) .post_one(url, row, headers, style)
      } else {
        .post_one(url, row, headers, style)
      }
    })
  })
  invisible(TRUE)
}

# -- Internals ----------------------------------------------------------------

# choose payload style
.pick_style <- function(style, data) {
  if (style == "auto") {
    if (inherits(data, "sf")) "feature" else "plain"
  } else style
}

# turn data.frame rows into named lists; preserve id_col name/value
.as_row_list <- function(df, id_col = "id") {
  # Replace NULL-like with NA to avoid tibble issues; send as null in JSON later
  df <- .df_nulls_to_na(df)
  
  # If sf → split geometry (lon/lat) so we can build GeoJSON Feature
  if (inherits(df, "sf")) {
    geom <- sf::st_geometry(df)
    # Expecting POINT geometries for now
    coords <- suppressWarnings(sf::st_coordinates(geom))
    # coords may be empty/non-point; handle NA safely
    if (nrow(coords) == nrow(df) && ncol(coords) >= 2) {
      df$.lon <- coords[, 1]
      df$.lat <- coords[, 2]
    } else {
      df$.lon <- NA_real_
      df$.lat <- NA_real_
    }
    df <- sf::st_drop_geometry(df)
  }
  
  # rowwise → list of lists
  rows <- split(df, seq_len(nrow(df)))
  purrr::map(rows, function(x) {
    x <- lapply(x, function(v) if (is.na(v)) NULL else v)
    # simplify 1-row data.frame to list of scalars
    purrr::list_flatten(unname(x))
  })
}

# safe indices for chunking
.chunk_indices <- function(n, k) {
  if (n <= 0) return(list())
  starts <- seq(1L, n, by = k)
  ends   <- pmin(n, starts + k - 1L)
  Map(function(a,b) a:b, starts, ends)
}

# join base collection URL and id → detail URL (handles trailing slash)
.join_url <- function(base, id) {
  base <- as.character(base)
  id   <- utils::URLencode(as.character(id), reserved = TRUE)
  if (grepl("/$", base)) paste0(base, id, "/") else paste0(base, "/", id, "/")
}

# HTTP helpers
.add_headers <- function(req, headers) {
  if (length(headers) > 0) {
    req <- do.call(httr2::req_headers, c(list(req), headers))
  }
  req
}

.send_json <- function(method, url, body, headers) {
  req <- httr2::request(url)
  req <- .add_headers(req, headers)
  req <- httr2::req_method(req, method)
  # jsonlite: NAs → null; scalar lists → unboxed
  req <- httr2::req_body_json(req, body = body, auto_unbox = TRUE, digits = NA, null = "null")
  res <- httr2::req_perform(req)
  # 2xx okay
  if (httr2::resp_status(res) >= 200 && httr2::resp_status(res) < 300) return(TRUE)
  # Pass through 404 to allow upsert fallback
  if (httr2::resp_status(res) == 404) return(FALSE)
  # Throw on other errors with any server message
  httr2::resp_check_status(res)
  TRUE
}

.post_one  <- function(url, row, headers, style) {
  payload <- .row_payload(row, style)
  .send_json("POST", url, payload, headers)
}

.patch_one <- function(url, row, headers, style) {
  payload <- .row_payload(row, style)
  .send_json("PATCH", url, payload, headers)
}

.try_patch <- function(url, row, headers, style) {
  tryCatch(.patch_one(url, row, headers, style),
           error = function(e) FALSE)
}

# Build the outgoing JSON object for one row
# plain:   {"field1":..., "field2":...}
# feature: {"type":"Feature","geometry":{...},"properties":{...},"id": "..."} (if id present)
.row_payload <- function(row, style = "plain") {
  if (identical(style, "feature")) {
    lon <- row[[".lon"]]; lat <- row[[".lat"]]
    props <- row
    props[[".lon"]] <- NULL; props[[".lat"]] <- NULL
    # keep id both at top-level and inside properties ONLY if you want (commonly servers ignore one)
    id_val <- props[["id"]]; # may be NULL
    # remove id from props if the server expects id at top-level only
    # props[["id"]] <- NULL
    
    geom <- NULL
    if (!is.null(lon) && !is.null(lat) && is.finite(lon) && is.finite(lat)) {
      geom <- list(type = "Point", coordinates = c(unname(lon), unname(lat)))
    }
    out <- list(
      type = "Feature",
      geometry = geom,
      properties = props
    )
    if (!is.null(id_val)) out$id <- id_val
    return(out)
  }
  
  # plain
  row[[".lon"]] <- NULL; row[[".lat"]] <- NULL
  row
}

# NULL→NA (shallow) for frames/lists to keep tibble happy upstream
.df_nulls_to_na <- function(x) {
  if (is.data.frame(x)) return(x)
  if (!is.list(x)) return(if (is.null(x)) NA else x)
  purrr::modify(x, ~ if (is.null(.x)) NA else .x)
}
